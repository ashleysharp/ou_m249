---
title: "Bayesian statistics"
output: html_document
date: "2025-07-05"
---

```{r}
library(tidyverse)
library(runjags)
library(coda)
```

# Baysean analysis for a proportion

## Likelihood for a proportion
```{r}
n <- 50
x <- 11

tibble(p = seq(0, 1, length.out = 1000)) |>
  mutate(likelihood = dbinom(x, n, p)) |> #p^x * (1 - p)^(n - x)
  ggplot(aes(p, likelihood)) +
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = x / n, linetype = "dashed") +
  labs(
    title = "Binomial likelihood",
    subtitle = paste0("n = ", n, ", x = ", x),
    x = "p",
    y = "Likelihood"
  ) +
  theme_minimal()
```
## Posterior for a proportion

```{r}
# data
n <- 9
x <- 6

# beta prior
a <- 2
b <- 6

df <- tibble(p = seq(0, 1, length.out = 2000)) |>
  mutate(
    dp = p[2] - p[1], # grid spacing
    prior = dbeta(p, a, b),
    likelihood_raw = dbinom(x, size = n, prob = p),
    # normalise likelihood so it integrates to 1
    likelihood = likelihood_raw / sum(likelihood_raw * dp),
    # unnormalised posterior
    posterior_unnorm = prior * likelihood,
    # normalise so it integrates to 1
    posterior = posterior_unnorm / sum(posterior_unnorm * dp),
    # closed-form posterior for comparison
    posterior_beta = dbeta(p, a + x, b + (n - x))
  ) 

df_long <- df |> 
  select(p, prior, likelihood, posterior) |>
  pivot_longer(-p, names_to = "curve", values_to = "density")

ggplot(df_long, aes(p, density, colour = curve)) +
  geom_line(linewidth = 0.6) +
  scale_colour_manual(
  values = c(
    prior = "#1f77b4",
    likelihood = "#ff7f0e",
    posterior = "#2ca02c"
  ),
  breaks = c("prior", "likelihood", "posterior"),
  labels = c(
    "Prior: Beta(a,b)",
    "Likelihood (normalised)",
    "Posterior: Beta(a+x, b+n-x)"
  )
) +
  labs(
    title = "Prior, likelihood, and posterior for a binomial model",
    subtitle = str_glue(
      "n = {n}, x = {x}; likelihood normalised via ∑ L(p)·Δp"
    ),
    x = "p",
    y = "Density",
    colour = NULL
  ) +
  theme_minimal()
```

# Standard priors

## Normal prior

```{r}
mu <- 100
sd <- sqrt(50)

pnorm(105, mu, sd) # lower.tail = TRUE
pnorm(92, mu, sd, lower.tail = FALSE) # upper tail
pnorm(105, mu, sd) - pnorm(92, mu, sd)
```
### CDF and Quantile functions

```{r}
tibble(x = seq(-3, 3, length.out = 1000)) |>
  mutate(p = pnorm(x)) %>% 
  ggplot(aes(x, p)) +
  geom_line(linewidth = 0.5) +
  theme_minimal()

tibble(p = seq(0.001, 0.999, length.out = 1000)) |>
  mutate(x = qnorm(p)) %>% 
  ggplot(aes(p, x)) +
  geom_line(linewidth = 0.5) +
  theme_minimal()
```

### Specifying using assessed values

```{r}
mode <- 20
# Assumed mode of the distribution.
# For a normal distribution, mode = mean = median,
# so this value is used as the mean.

L <- 0
U <- 43
# Supplied lower (Q1) and upper (Q3) quartiles.
# These are not necessarily symmetric about the mean
# if the asymmetry is not too severe a normal approximation should suffice

IQR <- U - L
# Interquartile range (Q3 − Q1)

a <- mode
# Mean of the normal distribution.

sd <- IQR / (2 * qnorm(0.75)) # or IQR / (qnorm(0.75) - qnorm(0.25))
# Convert IQR to standard deviation:
# IQR = 2 * z_0.75 * sd.
# Rearranging gives sd = IQR / (2 * z_0.75).

b  <- sd^2
# Variance corresponding to the derived standard deviation.

q25 <- qnorm(0.25, a, sd)
q75 <- qnorm(0.75, a, sd)

tibble(x = seq(a - 3*IQR, a + 3*IQR, length.out = 1000)) |>
  mutate(d = dnorm(x, mean = a, sd = sd)) |>
  ggplot(aes(x, d)) +
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = c(q25, q75), linetype = "dashed") +
  annotate(
    "text",
    x = q25, y = Inf,
    label = paste0("Q0.25 = ", round(q25, 2)),
    vjust = 1.2,
    size = 3
  ) +
  annotate(
    "text",
    x = q75, y = Inf,
    label = paste0("Q0.75 = ", round(q75, 2)),
    vjust = 1.2,
    size = 3
  ) +
  theme_minimal()
```

## Beta prior

