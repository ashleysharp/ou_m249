---
title: "Bayesian statistics"
output: html_document
date: "2025-07-05"
---

```{r}
library(tidyverse)
library(runjags)
library(coda)
library(glue)
```

# Standard priors

## Normal prior

```{r}
mu <- 100
sd <- sqrt(50)

pnorm(105, mu, sd) # lower.tail = TRUE
pnorm(92, mu, sd, lower.tail = FALSE) # upper tail
pnorm(105, mu, sd) - pnorm(92, mu, sd)
```

### CDF and Quantile functions

```{r}
tibble(x = seq(-3, 3, length.out = 1000)) |>
  mutate(p = pnorm(x)) %>% 
  ggplot(aes(x, p)) +
  geom_line(linewidth = 0.5) +
  theme_minimal()

tibble(p = seq(0.001, 0.999, length.out = 1000)) |>
  mutate(x = qnorm(p)) %>% 
  ggplot(aes(p, x)) +
  geom_line(linewidth = 0.5) +
  theme_minimal()
```

### Specifying using assessed values

```{r}
mode <- 20
# Assumed mode of the distribution.
# For a normal distribution, mode = mean = median,
# so this value is used as the mean.

L <- 0
U <- 43
# Supplied lower (Q1) and upper (Q3) quartiles.
# These are not necessarily symmetric about the mean
# if the asymmetry is not too severe a normal approximation should suffice

IQR <- U - L
# Interquartile range (Q3 − Q1)

a <- mode
# Mean of the normal distribution.

sd <- IQR / (2 * qnorm(0.75)) # or IQR / (qnorm(0.75) - qnorm(0.25))
# Convert IQR to standard deviation:
# IQR = 2 * z_0.75 * sd.
# Rearranging gives sd = IQR / (2 * z_0.75).

b  <- sd^2
# Variance corresponding to the derived standard deviation.

q25 <- qnorm(0.25, a, sd)
q75 <- qnorm(0.75, a, sd)

tibble(theta = seq(a - 3*IQR, a + 3*IQR, length.out = 1000)) |>
  mutate(d = dnorm(theta, mean = a, sd = sd)) |>
  ggplot(aes(theta, d)) +
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = c(q25, q75), linetype = "dashed") +
  annotate(
    "text",
    x = q25, y = Inf,
    label = paste0("Q0.25 = ", round(q25, 2)),
    vjust = 1.2,
    size = 3
  ) +
  annotate(
    "text",
    x = q75, y = Inf,
    label = paste0("Q0.75 = ", round(q75, 2)),
    vjust = 1.2,
    size = 3
  ) +
  theme_minimal()
```

## Beta prior

```{r}
a <- 4
b <- 2

mode <- (a - 1) / (a + b - 2)
s2 <- (a * b) / ((a + b)^2 * (a + b + 1))
sd <- sqrt(s2)

tibble(theta = seq(0.001, 0.999, length.out = 1000)) |>
  mutate(d = dbeta(theta, a, b)) |> 
  ggplot(aes(theta, d)) + 
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = mode, linetype = "dashed") +
  labs(
    x = expression(theta),
    y = "Density",
    subtitle = paste0(
      "Mode = ", round(mode, 3),
      ", SD = ", round(sd, 3)
    )
  ) +
  theme_minimal()
```


## Gamma prior
```{r}
a <- 6   # shape
b <- 4   # rate

mode <- (a - 1) / b
mean <- a / b
sd   <- sqrt(a) / b

tibble(theta = seq(0, 5, length.out = 1000)) |>
  mutate(d = dgamma(theta, shape = a, rate = b)) |> 
  ggplot(aes(theta, d)) + 
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = mode, linetype = "dashed") +
  geom_vline(xintercept = mean, linetype = "dotted") +
  labs(
    x = expression(theta),
    y = "Density",
    subtitle = paste0(
      "Gamma(shape = ", a, ", rate = ", b, ")  |  ",
      "Mode = ", round(mode, 3),
      ", Mean = ", round(mean, 3),
      ", SD = ", round(sd, 3)
    )
  ) +
  theme_minimal()

```

```{r}
pgamma(2, shape = 6, rate = 4)
qgamma(0.95, shape = 6, rate = 4)
```

# Likelihoods

## Normal likelihood
```{r}
n <- 10 # Number of observations
x_bar <- 30 # Sample mean
sigma2 <- 1 # Assumed known population variance
sigma <- sqrt(sigma2) # Assumed known population sd

tibble(
  theta = seq(
    x_bar - 2,
    x_bar + 2,
    length.out = 1000
  )
) |>
  mutate(
    likelihood = dnorm(x_bar, mean = theta, sd = sigma / sqrt(n))
  ) |>
  ggplot(aes(theta, likelihood)) +
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = x_bar, linetype = "dashed") +
  labs(
    title = "Normal likelihood for the mean",
    subtitle = paste0(
      "n = ", n,
      ", σ² = ", sigma2
    ),
    x = expression(theta),
    y = "Likelihood"
  ) +
  theme_minimal()

```

## Binomial likelihood
```{r}
n <- 10
x <- 2
p <- x/n

tibble(theta = seq(0, 1, length.out = 1000)) |>
  mutate(likelihood = dbinom(x, n, theta)) |> 
  # = theta^x * (1 - theta)^(n - x)
  ggplot(aes(theta, likelihood)) +
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = x / n, linetype = "dashed") +
  labs(
    title = "Binomial likelihood",
    subtitle = paste0("n = ", n, ", x = ", x, ", p = ", p),
    x = "theta",
    y = "likelihood"
  ) +
  theme_minimal()
```

## Poisson likelihood
```{r}
n <- 10
x_bar <- 2

tibble(theta = seq(0.001, 5, length.out = 1000)) |>
  mutate(
    likelihood = theta^(n * x_bar) * exp(-n * theta)
  ) |>
  ggplot(aes(theta, likelihood)) +
  geom_line(linewidth = 0.5) +
  geom_vline(xintercept = x_bar, linetype = "dashed") +
  labs(
    title = "Poisson likelihood",
    subtitle = paste0("n = ", n, ", x̄ = ", x_bar),
    x = "theta",
    y = "likelihood"
  ) +
  theme_minimal()
```

# Posteriors in conjugate models

## Normal / Normal
```{r}
# Data (summary)
n <- 15
x_bar <- 1.3
sigma2 <- 10  # known population variance
se <- sqrt(sigma2 / n)

# Prior: Normal(mu0, tau2)
mu0 <- 5
tau2 <- 4
tau <- sqrt(tau2)

# closed-form posterior parameters
prec0 <- 1 / tau2
preclik <- n / sigma2

post_var <- 1 / (prec0 + preclik)
post_sd  <- sqrt(post_var)
post_mean <- post_var * (prec0 * mu0 + preclik * x_bar)

# Grid
theta_min <- min(mu0 - 5*tau, x_bar - 5*se)
theta_max <- max(mu0 + 5*tau, x_bar + 5*se)

df <- tibble(theta = seq(theta_min, theta_max, length.out = 2000)) |>
  mutate(
    dtheta = theta[2] - theta[1],  # grid spacing
    # prior density (already integrates to 1)
    prior = dnorm(theta, mean = mu0, sd = tau),
    # likelihood as a function of theta: p(x_bar | theta)
    likelihood_raw = dnorm(x_bar, mean = theta, sd = se),
    # normalise likelihood over theta so it integrates to 1 (so it can be plotted on same "density" scale)
    likelihood = likelihood_raw / sum(likelihood_raw * dtheta),
    # unnormalised posterior on the grid
    posterior_unnorm = prior * likelihood,
    # normalise posterior
    posterior = posterior_unnorm / sum(posterior_unnorm * dtheta),
    # closed-form posterior for comparison
    posterior_norm = dnorm(theta, mean = post_mean, sd = post_sd)
  )

df_long <- df |>
  select(theta, prior, likelihood, posterior) |>
  pivot_longer(-theta, names_to = "curve", values_to = "density")

ggplot(df_long, aes(theta, density, colour = curve)) +
  geom_line(linewidth = 0.6) +
  scale_colour_manual(
    values = c(
      prior = "#1f77b4",
      likelihood = "#ff7f0e",
      posterior = "#2ca02c"
    ),
    breaks = c("prior", "likelihood", "posterior"),
    labels = c(
      "Prior",
      "Likelihood for θ (normalised)",
      "Posterior: Normal (closed-form)"
    )
  ) +
  labs(
    title = "Prior, likelihood, and posterior for a Normal/Normal model",
    subtitle = glue("n = {n}, x̄ = {x_bar}, known σ² = {sigma2}; posterior mean = {round(post_mean, 2)}, posterior var = {round(post_var, 2)}"),
    x = "theta",
    y = "density",
    colour = NULL
  ) +
  theme_minimal()
```

## Uniform / Normal

```{r}
# Data (summary)
n <- 15
x_bar <- 1.3
sigma2 <- 10  # known population variance
se <- sqrt(sigma2 / n)

# "Posterior parameters" under a flat (improper) prior on R:
# theta | x_bar ~ Normal(x_bar, sigma2/n)
post_mean <- x_bar
post_var  <- sigma2 / n
post_sd   <- sqrt(post_var)

# Grid (choose a sensible range around x̄)
theta_min <- x_bar - 6 * se
theta_max <- x_bar + 6 * se

df <- tibble(theta = seq(theta_min, theta_max, length.out = 2000)) |>
  mutate(
    dtheta = theta[2] - theta[1],  # grid spacing
    # Uniform prior over the grid range [theta_min, theta_max]
    prior_raw = 1,
    prior = prior_raw / sum(prior_raw * dtheta),  # integrates to 1 on the grid
    # Likelihood for theta: p(x̄ | theta)
    likelihood_raw = dnorm(x_bar, mean = theta, sd = se),
    likelihood = likelihood_raw / sum(likelihood_raw * dtheta),
    # Posterior on the grid (with uniform prior this equals likelihood after normalisation)
    posterior_unnorm = prior * likelihood,
    posterior = posterior_unnorm / sum(posterior_unnorm * dtheta),
    # Closed-form posterior under an (improper) flat prior on R
    posterior_norm = dnorm(theta, mean = post_mean, sd = post_sd)
  )

df_long <- df |>
  select(theta, prior, likelihood, posterior) |>
  pivot_longer(-theta, names_to = "curve", values_to = "density")

ggplot(df_long, aes(theta, density, colour = curve)) +
  geom_line(linewidth = 0.6) +
  scale_colour_manual(
    values = c(
      prior = "#1f77b4",
      likelihood = "#ff7f0e",
      posterior = "#2ca02c"
    ),
    breaks = c("prior", "likelihood", "posterior"),
    labels = c(
      "Prior: Uniform on grid range",
      "Likelihood for θ (normalised)",
      "Posterior (equals likelihood under flat prior)"
    )
  ) +
  labs(
    title = "Prior, likelihood, and posterior with a uniform prior",
    subtitle = glue(
      "n = {n}, x̄ = {x_bar}, known σ² = {sigma2}; ",
      "posterior mean = {round(post_mean, 3)}, posterior var = {round(post_var, 3)}"
    ),
    x = "theta",
    y = "density",
    colour = NULL
  ) +
  theme_minimal()
```

## Beta / Binomial

```{r}
# data
n <- 10
x <- 7

# beta prior
a <- 8
b <- 15

# closed-form posterior parameters
a_post <- a + x
b_post <- b + (n - x)

post_mean <- a_post / (a_post + b_post)
post_var  <- (a_post * b_post) / ((a_post + b_post)^2 * (a_post + b_post + 1))
post_sd   <- sqrt(post_var)

post_mode <- if (a_post > 1 && b_post > 1) (a_post - 1) / (a_post + b_post - 2) else NA_real_

# equal-tailed credible interval (e.g., 95%)
ci_level <- 0.95
alpha_ci <- (1 - ci_level) / 2
post_ci  <- qbeta(c(alpha_ci, 1 - alpha_ci), a_post, b_post)

df <- tibble(theta = seq(0, 1, length.out = 2000)) |>
  mutate(
    dtheta = theta[2] - theta[1], # grid spacing
    prior = dbeta(theta, a, b),
    likelihood_raw = dbinom(x, size = n, prob = theta),
    # normalise likelihood so it integrates to 1
    likelihood = likelihood_raw / sum(likelihood_raw * dtheta),
    # unnormalised posterior
    posterior_unnorm = prior * likelihood,
    # normalise so it integrates to 1
    posterior = posterior_unnorm / sum(posterior_unnorm * dtheta),
    # closed-form posterior for comparison
    posterior_beta = dbeta(theta, a_post, b_post)
  )

df_long <- df |>
  select(theta, prior, likelihood, posterior) |>
  pivot_longer(-theta, names_to = "curve", values_to = "density")

ggplot(df_long, aes(theta, density, colour = curve)) +
  geom_line(linewidth = 0.6) +
  scale_colour_manual(
    values = c(
      prior = "#1f77b4",
      likelihood = "#ff7f0e",
      posterior = "#2ca02c"
    ),
    breaks = c("prior", "likelihood", "posterior"),
    labels = c(
      "Prior: Beta(a,b)",
      "Likelihood (normalised)",
      "Posterior: Beta(a+x, b+n-x)"
    )
  ) +
  labs(
    title = "Prior, likelihood, and posterior for a binomial model",
    subtitle = str_glue(
      "n = {n}, x = {x}; posterior Beta({a_post}, {b_post}); ",
      "E[θ|x]={round(post_mean, 3)}, SD={round(post_sd, 3)}, ",
      "{round(ci_level*100)}% CI=[{round(post_ci[1],3)}, {round(post_ci[2],3)}]"
    ),
    x = "theta",
    y = "density",
    colour = NULL
  ) +
  theme_minimal()

```

## Gamma / Poisson

```{r}
# data (summary)
n <- 8
x_bar <- 0.75        # sample mean
s <- n * x_bar       # total count (sufficient statistic)

# damma prior (shape, rate)
alpha <- 1.5
beta <- 0.5

# closed-form posterior parameters (shape-rate)
alpha_post <- alpha + s          # = alpha + n*x_bar
beta_post  <- beta + n

post_mean <- alpha_post / beta_post
post_var  <- alpha_post / (beta_post^2)
post_sd   <- sqrt(post_var)

post_mode <- if (alpha_post > 1) (alpha_post - 1) / beta_post else NA_real_

# equal-tailed credible interval (e.g., 95%)
ci_level <- 0.95
alpha_ci <- (1 - ci_level) / 2
post_ci  <- qgamma(c(alpha_ci, 1 - alpha_ci), shape = alpha_post, rate = beta_post)

df <- tibble(theta = seq(0.001, 6, length.out = 2000)) |>
  mutate(
    dtheta = theta[2] - theta[1],  # grid spacing
    # prior
    prior = dgamma(theta, shape = alpha, rate = beta),
    # likelihood for θ given (n, x̄)
    # kernel of Poisson likelihood: θ^(n x̄) exp(-n θ)
    likelihood_raw = theta^(n * x_bar) * exp(-n * theta),
    # normalise likelihood so it integrates to 1 (for plotting)
    likelihood = likelihood_raw / sum(likelihood_raw * dtheta),
    # unnormalised posterior
    posterior_unnorm = prior * likelihood,
    # normalise posterior
    posterior = posterior_unnorm / sum(posterior_unnorm * dtheta),
    # closed-form posterior for comparison
    posterior_gamma = dgamma(theta, shape = alpha_post, rate = beta_post)
  )

df_long <- df |>
  select(theta, prior, likelihood, posterior) |>
  pivot_longer(-theta, names_to = "curve", values_to = "density")

ggplot(df_long, aes(theta, density, colour = curve)) +
  geom_line(linewidth = 0.6) +
  scale_colour_manual(
    values = c(
      prior = "#1f77b4",
      likelihood = "#ff7f0e",
      posterior = "#2ca02c"
    ),
    breaks = c("prior", "likelihood", "posterior"),
    labels = c(
      "Prior: Gamma(α, β)",
      "Likelihood (normalised)",
      "Posterior: Gamma(α + n x̄, β + n)"
    )
  ) +
  labs(
    title = "Prior, likelihood, and posterior for a Gamma–Poisson model",
    subtitle = str_glue(
      "n = {n}, x̄ = {x_bar}, total s = n x̄ = {s}; ",
      "posterior Gamma({round(alpha_post,3)}, {round(beta_post,3)}); ",
      "E[θ|x]={round(post_mean,3)}, SD={round(post_sd,3)}, ",
      "{round(ci_level*100)}% CI=[{round(post_ci[1],3)}, {round(post_ci[2],3)}]"
    ),
    x = "theta",
    y = "density",
    colour = NULL
  ) +
  theme_minimal()

```

# Baysean inference

## Alzheimer's progression
### Normal / Normal
```{r}
# Data (summary)
n <- 20
x_bar <- -36
sigma2 <- 100  # known population variance
se <- sqrt(sigma2 / n)

# Prior: Normal(mu0, tau2)
mu0 <- -25
tau2 <- 64
tau <- sqrt(tau2)

# Conjugate posterior params
prec0 <- 1 / tau2
preclik <- n / sigma2

post_var <- 1 / (prec0 + preclik)
post_sd  <- sqrt(post_var)
post_mean <- post_var * (prec0 * mu0 + preclik * x_bar)

# Grid
theta_min <- min(mu0 - 5*tau, x_bar - 5*se)
theta_max <- max(mu0 + 5*tau, x_bar + 5*se)

df <- tibble(theta = seq(theta_min, theta_max, length.out = 2000)) |>
  mutate(
    dtheta = theta[2] - theta[1],  # grid spacing
    # prior density (already integrates to 1)
    prior = dnorm(theta, mean = mu0, sd = tau),
    # likelihood as a function of theta: p(x_bar | theta)
    likelihood_raw = dnorm(x_bar, mean = theta, sd = se),
    # normalise likelihood over theta so it integrates to 1 (so it can be plotted on same "density" scale)
    likelihood = likelihood_raw / sum(likelihood_raw * dtheta),
    # unnormalised posterior on the grid
    posterior_unnorm = prior * likelihood,
    # normalise posterior
    posterior = posterior_unnorm / sum(posterior_unnorm * dtheta),
    # closed-form posterior for comparison
    posterior_norm = dnorm(theta, mean = post_mean, sd = post_sd)
  )

df_long <- df |>
  select(theta, prior, likelihood, posterior) |>
  pivot_longer(-theta, names_to = "curve", values_to = "density")

ggplot(df_long, aes(theta, density, colour = curve)) +
  geom_line(linewidth = 0.6) +
  scale_colour_manual(
    values = c(
      prior = "#1f77b4",
      likelihood = "#ff7f0e",
      posterior = "#2ca02c"
    ),
    breaks = c("prior", "likelihood", "posterior"),
    labels = c(
      "Prior",
      "Likelihood for θ (normalised)",
      "Posterior: Normal (closed-form)"
    )
  ) +
  labs(
    title = "Prior, likelihood, and posterior for a Normal/Normal model",
    subtitle = glue("n = {n}, x̄ = {x_bar}, known σ² = {sigma2}; posterior mean = {round(post_mean, 2)}, posterior var = {round(post_var, 2)}"),
    x = "theta",
    y = "density",
    colour = NULL
  ) +
  theme_minimal()
```

### Posterior probabilities
```{r}
pnorm(-35, mean = post_mean, sd = post_sd) - pnorm(-40, mean = post_mean, sd = post_sd)

pnorm(-40, mean = post_mean, sd = post_sd, lower.tail = FALSE)

pnorm(-35, mean = post_mean, sd = post_sd)
```

### Posterior quantiles
```{r}
qnorm(0.95, mean = post_mean, sd = post_sd)
```

### Posterior credible interval
```{r}
qnorm(c(0.05, 0.95), mean = post_mean, sd = post_sd)
```

### Highest posterior density
```{r}
samp <- rnorm(100000, mean = post_mean, sd = post_sd)
HPDinterval(as.mcmc(samp), prob = 0.9)
```

## Memory tests

### Uniform / Normal

```{r}
# Data (summary)
n <- 12
x_bar <- 7.5
sigma2 <- 90  # known population variance
se <- sqrt(sigma2 / n)

# "Posterior parameters" under a flat (improper) prior on R:
# theta | x_bar ~ Normal(x_bar, sigma2/n)
post_mean <- x_bar
post_var  <- sigma2 / n
post_sd   <- sqrt(post_var)

# Grid (choose a sensible range around x̄)
theta_min <- x_bar - 6 * se
theta_max <- x_bar + 6 * se

df <- tibble(theta = seq(theta_min, theta_max, length.out = 2000)) |>
  mutate(
    dtheta = theta[2] - theta[1],  # grid spacing
    # Uniform prior over the grid range [theta_min, theta_max]
    prior_raw = 1,
    prior = prior_raw / sum(prior_raw * dtheta),  # integrates to 1 on the grid
    # Likelihood for theta: p(x̄ | theta)
    likelihood_raw = dnorm(x_bar, mean = theta, sd = se),
    likelihood = likelihood_raw / sum(likelihood_raw * dtheta),
    # Posterior on the grid (with uniform prior this equals likelihood after normalisation)
    posterior_unnorm = prior * likelihood,
    posterior = posterior_unnorm / sum(posterior_unnorm * dtheta),
    # Closed-form posterior under an (improper) flat prior on R
    posterior_norm = dnorm(theta, mean = post_mean, sd = post_sd)
  )

df_long <- df |>
  select(theta, prior, likelihood, posterior) |>
  pivot_longer(-theta, names_to = "curve", values_to = "density")

ggplot(df_long, aes(theta, density, colour = curve)) +
  geom_line(linewidth = 0.6) +
  scale_colour_manual(
    values = c(
      prior = "#1f77b4",
      likelihood = "#ff7f0e",
      posterior = "#2ca02c"
    ),
    breaks = c("prior", "likelihood", "posterior"),
    labels = c(
      "Prior: Uniform on grid range",
      "Likelihood for θ (normalised)",
      "Posterior (equals likelihood under flat prior)"
    )
  ) +
  labs(
    title = "Prior, likelihood, and posterior with a uniform prior",
    subtitle = glue(
      "n = {n}, x̄ = {x_bar}, known σ² = {sigma2}; ",
      "posterior mean = {round(post_mean, 3)}, posterior var = {round(post_var, 3)}"
    ),
    x = "theta",
    y = "density",
    colour = NULL
  ) +
  theme_minimal()
```
### Posterior probabilities
```{r}
pnorm(0, mean = post_mean, sd = post_sd, lower.tail = FALSE)
```

### Highest posterior density
```{r}
samp <- rnorm(100000, mean = post_mean, sd = post_sd)
HPDinterval(as.mcmc(samp), prob = 0.99)
```

# Introduction to WinBUGS (rjags)

## Beta(19,19)

```{r warning=FALSE}
# WinBUGS / JAGS model written directly as text
model_string <- "
model {
  theta1 ~ dbeta(19,19)
}
"

# Run the model
fit <- run.jags(
  model    = model_string,
  monitor  = "theta1",
  n.chains = 1,
  burnin   = 1000,
  sample   = 1000
)
```

```{r}
fit
```

### Kernel density plot
```{r}
# Extract posterior draws (coda mcmc object)
mcmc_obj <- fit$mcmc

# Plot with coda
densplot(mcmc_obj[, "theta1"], main = "Posterior density: theta1")
```

```{r}
# Convert to a simple numeric vector
theta_samples <- as.numeric(mcmc_obj[[1]][, "theta1"])

mean(theta_samples)
var(theta_samples)

# True values for Beta(a, b)
a <- 19
b <- 19

mean_beta <- a / (a + b)
var_beta  <- (a * b) / ((a + b)^2 * (a + b + 1))

mean_beta
var_beta

# Other quantiles
quantile(theta_samples, c(0.05, 0.95))
```

## Transformations of parameters

### Sex ratio of births in Milton Keynes
```{r warning=FALSE}
model_string <- "
model {
  theta ~ dbeta(1447,1393)
  phi <- theta/(1-theta)
  logodds <- log(theta/(1-theta))
}
"

fit <- run.jags(
  model    = model_string,
  monitor  = c("theta", "phi", "logodds"),
  n.chains = 1,
  burnin   = 1000,
  sample   = 10000
)

fit

densplot(fit$mcmc[, "theta"], main = "Posterior density: theta")
densplot(fit$mcmc[, "phi"], main = "Posterior density: phi")
densplot(fit$mcmc[, "logodds"], main = "Posterior density: logodds")
```

# Multivariate problems

## Density of the Earth, normal gamma

```{r warning=FALSE}
model_string <- "
model {
  mu ~ dnorm(5.44,prec)
  prec <- tau/0.0343
  tau ~ dgamma(16.7,0.982)
}
"

fit <- run.jags(
  model    = model_string,
  monitor  = c("mu", "tau", "prec"),
  n.chains = 1,
  burnin   = 1000,
  sample   = 1000
)

fit

densplot(fit$mcmc[, "mu"], main = "Posterior density: mu")
densplot(fit$mcmc[, "tau"], main = "Posterior density: tau")
```
### Scatterplot
```{r}
draws <- as.matrix(fit$mcmc) |>
  as_tibble()

draws |>
  ggplot(aes(x = tau, y = mu)) +
  geom_point(alpha = 0.4, size = 0.9) +
  labs(
    title = "Joint posterior: mu vs tau",
    x = "tau",
    y = "mu"
  ) +
  theme_minimal()
```

## Difference between binomial proportions

```{r warning=FALSE}
model_string <- "
model {
  theta1 ~ dbeta(19,19)
	theta2 ~ dbeta(5,15)
	d <- theta1 - theta2
}
"

fit <- run.jags(
  model    = model_string,
  monitor  = c("d"),
  n.chains = 1,
  burnin   = 1000,
  sample   = 10000
)

fit

densplot(fit$mcmc[, "d"], main = "Posterior density: d")
```

# MCMC

```{r warning=FALSE}
data_list <- list(x=c(5.50,5.61,4.88,5.07,5.26,5.55,5.36,5.29,5.58,5.65,5.57,5.53,5.62,5.29,5.44,5.34,5.79,5.10,5.27,5.39,5.42,5.47,5.63,5.34,5.46,5.30,5.75,5.68,5.85),n=29)

model_string <- "
model {
  # Likelihood
  for (i in 1:n) {
    x[i] ~ dnorm(mu, tau)
  }

  # Priors
  mu  ~ dnorm(4, 1)
  tau ~ dgamma(2.2, 0.15)
}
"

fit <- run.jags(
  model    = model_string,
  data     = data_list,
  monitor  = c("mu", "tau"),
  n.chains = 1,
  burnin   = 1000,
  sample   = 1000
)

fit

densplot(fit$mcmc[, "mu"], main = "Posterior density: mu")
densplot(fit$mcmc[, "tau"], main = "Posterior density: tau")
```

```{r}
draws <- as.matrix(fit$mcmc) |>
  as_tibble()

draws |>
  ggplot(aes(x = tau, y = mu)) +
  geom_point(alpha = 0.4, size = 0.9) +
  labs(
    title = "Joint posterior: mu vs tau",
    x = "tau",
    y = "mu"
  ) +
  theme_minimal()
```

### Trace plot
```{r}
traceplot(fit$mcmc[, "mu"],  main = "Trace: mu")
traceplot(fit$mcmc[, "tau"], main = "Trace: tau")
```

# MCMC samples from multiple chains

##Traffic platoons
```{r warning=FALSE}
data_list <- list(
  y = c(256,72,33,21,10,4,4,0,2),
  m = 9,
  zeros = rep(0, 9)
)

model_string <- "
model {
  for (i in 1:m){
    phi[i] <- -y[i]*(-theta*i + (i-1)*log(theta*i) - logfact(i))
    zeros[i] ~ dpois(phi[i])
  }
  ltheta ~ dnorm(0,1.0E-4)
  theta <- ilogit(ltheta)
}
"

fit <- run.jags(
  model    = model_string,
  data     = data_list,
  monitor  = c("ltheta", "theta"),
  n.chains = 3,
  burnin   = 4000,
  sample   = 5000
)

fit

densplot(fit$mcmc[, "ltheta"], main = "Posterior density: ltheta")
densplot(fit$mcmc[, "theta"], main = "Posterior density: theta")

traceplot(fit$mcmc[, "ltheta"], main = "Trace: ltheta")
traceplot(fit$mcmc[[1]][, "ltheta"], main = "Trace: ltheta (chain 1)")
traceplot(fit$mcmc[, "theta"], main = "Trace: theta")
```

## Lung cancer

```{r warning=FALSE}
data_list <- list(x=c(10,1,0,2,4,2,2,7,19,10,11,12,10,5,2,1,2,3,2,3,2,3,2,1,2,1,2,1,3,0,6,4,3,1,0,1,0,2,2,1,1,0,1,0,1,1,4),n=47)

model_string <- "
model
{
	for (i in 1:n){
		x[i] ~ dpois(lambda)
	}
    llambda ~ dnorm(normmean,normprec)
	normmean <- log(5)
	normprec <- 1/(0.421*0.421)
	lambda <- exp(llambda)
}
"

fit <- run.jags(
  model    = model_string,
  data     = data_list,
  monitor  = c("lambda", "llambda"),
  n.chains = 3,
  burnin   = 4000,
  sample   = 1000
)

fit

densplot(fit$mcmc[, "lambda"], main = "Posterior density: lambda")
densplot(fit$mcmc[, "llambda"], main = "Posterior density: llambda")

traceplot(fit$mcmc[, "lambda"], main = "Trace: lambda")
traceplot(fit$mcmc[, "llambda"], main = "Trace: llambda")
```

# Baysean random effects meta-analysis

```{r warning=FALSE}
data_list <- list(k=8,xc=c(2,23,7,1,8,9,3,118),xm=c(1,9,2,1,10,1,1,90),nc=c(36,135,200,46,148,56,23,1157),nm=c(40,135,200,48,150,59,25,1159))

model_string <- "
model 
{
	for(i in 1:k) {
		xm[i] ~ dbin(thetam[i],nm[i])
		xc[i] ~ dbin(thetac[i],nc[i])
		thetac[i] ~ dunif(0,1)
		del[i] ~ dnorm(delta,tau)
		logit(thetam[i]) <- logit(thetac[i])+del[i]
		OR[i] <- exp(del[i])
	}
	delta ~ dnorm(0,prec)
	prec <- 1/0.0306
	sigma ~ dunif(0,100)
	tau <- 1/(sigma*sigma)
	oddsratio <- exp(delta)
}
"

fit <- run.jags(
  model    = model_string,
  data     = data_list,
  monitor  = c("thetac", "delta", "oddsratio", "del", "OR", "sigma"),
  n.chains = 3,
  burnin   = 4000,
  sample   = 1500
)

fit

densplot(fit$mcmc[, "delta"], main = "Posterior density: delta")
traceplot(fit$mcmc[, "delta"], main = "Trace: delta")

densplot(fit$mcmc[, "oddsratio"], main = "Posterior density: oddsratio")
traceplot(fit$mcmc[, "oddsratio"], main = "Trace: oddsratio")
```
