---
title: "Multivariate analysis"
output: html_document
date: "2025-07-05"
---

```{r message=FALSE}
library(tidyverse)
library(janitor)
library(haven)
library(GGally)

data(iris)
```

# Data visualisation

## Scatterplots

### Housing

```{r}
housing <- read_sav("data/Book 3/housing.sav")
```

```{r}
ggplot(
  housing,
  aes(
    income,
    houseprice,
    fill  = factor(region),
    shape = factor(region)
  )
) +
  geom_point(
    size   = 2,
    colour = "black",
    alpha  = 0.5
  ) +
  scale_shape_manual(values = rep(c(21, 22, 23), 3)) +
  theme_minimal()
```

### Crime

```{r}
crimeloss1 <- read_sav("data/Book 3/crimeloss1.sav")
```

```{r}
ggplot(
  crimeloss1,
  aes(
    totexp,
    totloss,
    shape = region
  )
) +
  geom_point(
    size   = 2,
    colour = "black",
    alpha  = 0.7
  ) +
  theme_minimal()
```

## Matrix scatterplots

### Iris

```{r message=FALSE}
ggpairs(
  iris,
  columns = 1:4,
  aes(color = Species, alpha = 0.7)
) + 
  theme_minimal()
```

### Local education authorities

```{r}
lea <- read_sav("data/Book 3/lea.sav")
```

```{r}
ggpairs(
  lea,
  columns = 2:4,
) + 
  theme_minimal()
```

```{r}
crimeloss2 <- read_sav("data/Book 3/crimeloss2.sav")
```

```{r message=FALSE}
ggpairs(
  crimeloss2,
  columns = 2:5,
) + 
  theme_minimal()
```

## Profile plots

### Iris

```{r}
iris_long <- iris |>
  mutate(id = row_number()) |>
  pivot_longer(
    cols = Sepal.Length:Petal.Width,
    names_to = "variable",
    values_to = "value"
  ) |>
  group_by(variable) |>
  mutate(variable_mean = mean(value)) |>
  ungroup() |>
  mutate(
    variable = reorder(variable, -variable_mean)
  )

ggplot(
  iris_long,
  aes(x = variable, y = value, colour = Species, group = id)
) +
  geom_line(alpha = 0.25, linewidth = 0.6) +
  theme_minimal() +
  labs(
    x = NULL,
    y = "Measurement",
    title = "Iris Profile Plot"
  )
```

### Echinacea

```{r}
echinacea <- read_sav("data/Book 3/echinacea.sav")
```

```{r}
echinacea_long <- echinacea |>
  pivot_longer(
    cols = lCu:lCa,
    names_to = "variable",
    values_to = "value"
  ) |>
  group_by(variable) |>
  mutate(variable_mean = mean(value)) |>
  ungroup() |>
  mutate(
    variable = reorder(variable, variable_mean)
  )

ggplot(
  echinacea_long,
  aes(x = variable, y = value, col = sample, lty = sample, group = sample)
) +
  geom_line(alpha = 0.5, linewidth = 1) +
  theme_minimal() +
  labs(
    x = NULL,
    y = "Measurement",
    title = "Echinacea Profile Plot"
  )
```

### Iberian hams

```{r}
hams <- read_sav("data/Book 3/hams.sav")
```

```{r}
hams_long <- hams |>
  pivot_longer(
    cols = s1:s15,
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(
    variable = factor(variable, levels = paste0("s", 1:15)),
    setting = factor(setting)
  )

ggplot(
  hams_long,
  aes(x = variable, y = value, col = setting, group = setting)
) +
  geom_line(alpha = 0.5, linewidth = 0.8) +
  theme_minimal() +
  labs(
    x = NULL,
    y = "Measurement",
    title = "Iberian Hams Profile Plot"
  )
```

# Numerical summaries and standardisation

## Mean vectors

### Housing

```{r}
housing |>
  summarise(
    across(
      c(houseprice, income),
      \(x) mean(x, na.rm = TRUE) # Lambda function x |-> mean(x)
    )
  )
```

```{r}
housing |>
  select(houseprice, income) |>
  colMeans(na.rm = TRUE)
```

```{r}
housing |>
  group_by(region) |> 
  summarise(
    across(
      c(houseprice, income),
      \(x) mean(x, na.rm = TRUE) # Lambda function x |-> mean(x)
    )
  )
```

## Standardising variables

### Housing

```{r}
Z_housing <- housing |>
  mutate(
    across(
      c(houseprice, income),
      \(x) as.numeric(scale(x)),#scale() outputs a matrix, make numeric
      .names = "Z{.col}"
      )
    )

Z_housing |>
  summarise(
    across(
      c(Zhouseprice, Zincome),
      \(x) mean(x, na.rm = TRUE) # Lambda function x |-> mean(x)
    )
  )
```

## Covariance and correlation matrices

### Maths ability

```{r}
mathsability <- read_sav("data/Book 3/mathsability.sav")
```

```{r}
cov(mathsability |> select(age:algebra))
```

```{r}
cor(mathsability |> select(age:algebra))
```

### Crime

```{r}
crimeloss2 <- read_sav("data/Book 3/crimeloss2.sav")
```

```{r}
crimeloss2 |> summarise(
  across(
    proploss:localexp,
    \(x) mean(x, na.rm = TRUE)
    )
  )
```

```{r}
cov(crimeloss2 |> select(proploss:localexp))
```

```{r}
cor(crimeloss2 |> select(proploss:localexp))
```

# Principle Component analysis

## Iris

### base

```{r}
X <- as.matrix(iris[, 1:4])

# --- choose: covariance PCA (center only) or correlation PCA (center + scale)
# Xc <- scale(X, center = TRUE, scale = FALSE)  # covariance version
Z  <- scale(X, center = TRUE, scale = TRUE) # correlation version

# S <- cov(Xc)               # same as t(Xc) %*% Xc / (nrow(Xc) - 1)
S <- cov(Z)

eig <- eigen(S)

values  <- eig$values      # eigenvalues (variances of PCs)
vectors <- eig$vectors     # eigenvectors (loadings)

# PC scores
scores <- Z %*% vectors

# proportion variance explained
pve <- values / sum(values)

values
pve
head(scores)

pc1 <- Z %*% vectors[,1]
pc2 <- Z %*% vectors[,1:2]
```

### prcomp()

```{r}
X <- iris[, 1:4]

p <- prcomp(X, center = TRUE, scale. = TRUE)  # correlation PCA
summary(p)

# loadings (eigenvectors)
p$rotation

# scores
head(p$x)

# eigenvalues of correlation PCA:
p$sdev^2

# proportion variance explained
p$sdev^2 / sum(p$sdev^2)
```

## Standardised data

### Maths ability

```{r}
X <- mathsability[, 3:6]
p <- prcomp(X, center = TRUE, scale. = TRUE)  # correlation PCA
```

```{r}
summary(p)
```

```{r}
# eigenvalues of correlation PCA:
p$sdev
p$sdev^2
```

```{r}
# loadings (eigenvectors). Note: sum of squared loadings = 1
p$rotation
```

```{r}
sum(p$rotation[,1]^2)
```

```{r}
# loadings (eigenvectors). Note: SGSS convention (the sum of squared loadings for component k equals the variance of that component). Negative is an artifact of axis choice.

sweep(-p$rotation, 2, p$sdev, `*`)
```

### Wells

```{r}
wells <- read_sav("data/Book 3/wells.sav")
```

```{r}
wells |>
  summarise(
    across(
      2:26,
      c(
        mean = \(x) mean(x, na.rm = TRUE),
        sd   = \(x) sd(x, na.rm = TRUE)
      )
    )
  )
```

```{r}
X <- wells[, 2:26]
p <- prcomp(X, center = TRUE, scale. = TRUE)  # correlation PCA
```

```{r}
eig <- p$sdev^2 # eigenvalues
keep <- eig[eig > 1] # Kaiser's criterion
keep
```

```{r}
pve <- eig / sum(eig) # proportion variance explained
cpve <- cumsum(pve) # cumulative
pve[1:5]
cpve[1:5]
```

```{r}
p$rotation[, 1:2]
```

## Unstandardised data

### Local education authorities

```{r}
X <- lea[,2:4]
p <- prcomp(X, center = TRUE, scale. = FALSE)
```

```{r}
summary(p)
```

```{r}
eig <- p$sdev^2
keep <- eig[eig > mean(eig)] # Kaiser's criterion, components with variance greater than the average
eig
keep
```

```{r}
tve <- sum(eig)
pve <- keep / tve
tve
pve
```

### Maths ability

```{r}
mathsability2 <- read_sav("data/Book 3/mathsability2.sav")
```

#### Standardised

```{r}
X <- mathsability2 |> select(A:I)
p <- prcomp(X, center = TRUE, scale. = TRUE)
```

```{r}
summary(p)
```

```{r}
eig <- p$sdev^2
keep <- eig[eig > 1]
eig
keep
```

```{r}
-p$rotation[,1:2]
```

#### Unstandardised

```{r}
X <- mathsability2 |> select(A:I)
p <- prcomp(X, center = TRUE, scale. = FALSE)
```

```{r}
summary(p)
```

```{r}
eig <- p$sdev^2
keep <- eig[eig > mean(eig)]
eig
keep
```

Variables with largest variances also have largest loadings (PCA chases variance)

```{r}
mathsability2 |> summarise(
  across(
    A:I,
    \(x) var(x, na.rm = )
  )
) |> 
  pivot_longer(everything())

-p$rotation[,1:3]
```

# Extracting and plotting principle components

## Scree plot

```{r}
X <- mathsability2 |> select(A:I)
p <- prcomp(X, center = TRUE, scale. = TRUE)
eig <- p$sdev^2
```

```{r}
ggplot(
  tibble(n = seq_along(eig), eig = eig),
  aes(x = n, y = eig)
) +
  geom_point() +
  geom_line() +
  scale_x_continuous(breaks = seq_along(eig)) +
  theme_minimal()
```

```{r}
-p$rotation[, 1:3]
```

## Scatterplot

```{r}
as_tibble(-p$x[,1:3]) |> ggpairs() + 
  theme_minimal()
```

```{r}
mathsability2_aug <- mathsability2 |>
  bind_cols(
    as_tibble(p$x[, 1:2]) |>
      rename(PC1 = 1, PC2 = 2)
  )
```

```{r}
ggplot(mathsability2_aug, aes(x = PC1, y = PC2, col = form)) + 
  geom_point() + 
  theme_minimal()
```

# Canonical discriminant analysis

## Iris

### Variance pooled within groups

Using group variances
$$
s_W^2
=
\frac{\sum_{g=1}^G (n_g - 1)\, s_g^2}
{\sum_{g=1}^G (n_g - 1)}
$$

Using raw derivations from group means
$$
s_W^2
=
\frac{
\sum_{g=1}^G \sum_{i \in g}
\left(x_{ig} - \bar{x}_g\right)^2
}{
\sum_{g=1}^G (n_g - 1)
}
$$

Connecting identity
$$
\begin{aligned}
\bar{x}_g &= \frac{1}{n_g}\sum_{i \in g} x_{ig} \\
s_g^2 &= \frac{1}{n_g - 1}
\sum_{i \in g}
\left(x_{ig} - \bar{x}_g\right)^2 \\
(n_g - 1)s_g^2 &=
\sum_{i \in g}
\left(x_{ig} - \bar{x}_g\right)^2
\end{aligned}
$$

```{r}
iris_groups <- iris |> 
  pivot_longer(1:4, names_to = "variable", values_to = "value") |> 
  group_by(Species, variable) |>
  summarise(n = n(),
            sse = sum((value - mean(value))^2),
            s2 = sse / (n-1),
            .groups = "drop") |> 
  select(variable, everything()) |> 
  arrange(variable)

iris_groups
```


```{r}
iris_pooled_w <- iris_groups |>
  group_by(variable) |>
  summarise(
    msw = sum(sse) / sum(n - 1), # pooled from sse
    #msw  = sum((n - 1)*s2) / sum(n - 1), # pooled from s2
    .groups = "drop"
  )
iris_pooled_w
```

### Variance pooled between groups

```{r}
grand_mean <- mean(iris$Petal.Length)
iris_b <- iris_groups |> mutate(sq_res = n_g*(mean_g - grand_mean)^2) |>
  summarise(ssb = sum(sq_res),
            df = n()-1,
            msb = ssb/df)
iris_b
```

```{r}
str_c("ssb = ", round(iris_b$ssb, 2),
      ", msb = ", round(iris_b$msb, 2), 
      ", ssw = ", round(iris_w$ssw, 2),
      ", msw = ", round(iris_w$msw, 2),
      ", msb/msw = ", round(iris_b$msb/iris_w$msw, 2),
      ", ss_t = ", round(iris_b$ssb + iris_w$ssw, 2))
```

```{r}
summary(aov(Petal.Length ~ Species, data = iris))
summary(aov(Petal.Width ~ Species, data = iris))
summary(aov(Sepal.Length ~ Species, data = iris))
summary(aov(Sepal.Width ~ Species, data = iris))
```

### Covariance pooled within groups

```{r}
iris |> mutate(cp = (Sepal.Length - mean(Sepal.Length)) * (Petal.Width - mean(Petal.Width))) |>
  summarise(scp = sum(cp), # Sum of cross products
            cov = scp/(n()-1),
            cor = cov/(sd(Sepal.Length)*sd(Petal.Width)))
```

```{r}
iris_centred <- scale(iris[, 1:4], center = TRUE, scale = FALSE)
t(iris_centred) %*% iris_centred / (nrow(iris) - 1)
#crossprod(iris_centred) / (nrow(iris) - 1)
# cov(iris[, 1:4])
```

```{r}
iris_standardised <- scale(iris[, 1:4], center = TRUE, scale = TRUE)
t(iris_standardised) %*% iris_standardised / (nrow(iris) - 1) 
# crossprod(iris_standardised) / (nrow(iris) - 1) 
# cor(iris[, 1:4])
```

```{r}
X <- as.matrix(iris[, 1:4])   # numeric variables
g <- iris$Species              # grouping factor

p <- ncol(X)
n <- nrow(X)
groups <- levels(g)
G <- length(groups)
```

```{r}
SW <- matrix(0, p, p)

for (grp in groups) {
  Xg <- X[g == grp, ]
  Xg_centered <- scale(Xg, center = TRUE, scale = FALSE)
  SW <- SW + t(Xg_centered) %*% Xg_centered
}
```

```{r}
SW_cov <- SW / (n - G)
SW_cov
```

### Covariance pooled between groups
```{r}
grand_mean <- colMeans(X)
SB <- matrix(0, p, p)

for (grp in groups) {
  Xg <- X[g == grp, ]
  ng <- nrow(Xg)
  mean_g <- colMeans(Xg)
  
  diff <- matrix(mean_g - grand_mean, ncol = 1)
  SB <- SB + ng * (diff %*% t(diff))
}
```

```{r}
SB_cov <- SB / (G - 1)
SB_cov
```

```{r}
Xc <- scale(X, center = TRUE, scale = FALSE)
ST <- t(Xc) %*% Xc

all.equal(ST, SW + SB)
```

### lda()

```{r}
# Fit LDA
fit <- lda(Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
           data = iris)

fit
# Class priors, group means, and linear discriminants (scaling)

# Predict
pred <- predict(fit, newdata = iris)
names(pred)
# "class" "posterior" "x"  (x = LD scores)

# Confusion matrix (training set)
table(Truth = iris$Species, Pred = pred$class)

# Accuracy
mean(pred$class == iris$Species)

# LD scores
head(pred$x)   # columns LD1, LD2 (since 3 classes -> at most 2 LDs)
```

```{r}
lda_df <- data.frame(
  LD1 = pred$x[, 1],
  LD2 = pred$x[, 2],
  Species = iris$Species
)

ggplot(lda_df, aes(x = LD1, y = LD2, colour = Species)) +
  geom_point(size = 2, alpha = 0.8) +
  labs(
    x = "LD1",
    y = "LD2",
    colour = "Species"
  ) +
  theme_minimal()
```

## Banknotes

```{r}
banknotes <- read_sav("data/Book 3/banknotes.sav")
```

## Satelites

```{r}
satellite <- read_sav("data/Book 3/satellite.sav")
```

# Allocation

```{r}
banknotes2 <- read_sav("data/Book 3/banknotes2.sav")
```

```{r}
testsat <- read_sav("data/Book 3/testsat.sav")
```

```{r}
set.seed(123)
n <- 300

Sigma <- matrix(
  c(1.0,  0.6,  0.3,
    0.6,  1.0,  0.5,
    0.3,  0.5,  1.0),
  nrow = 3
)

dat <- mvrnorm(
  n = n,
  mu = c(0, 0, 0),
  Sigma = Sigma
)

dat <- as.data.frame(dat)
names(dat) <- c("x1", "x2", "x3")

cor(dat)
```
